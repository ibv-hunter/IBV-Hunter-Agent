// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: cline/hooks.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
function createBaseHookInput() {
    return {
        clineVersion: "",
        hookName: "",
        timestamp: "",
        taskId: "",
        workspaceRoots: [],
        userId: "",
        preToolUse: undefined,
        postToolUse: undefined,
        userPromptSubmit: undefined,
        taskStart: undefined,
        taskResume: undefined,
        taskCancel: undefined,
        taskComplete: undefined,
        preCompact: undefined,
    };
}
export const HookInput = {
    encode(message, writer = new BinaryWriter()) {
        if (message.clineVersion !== "") {
            writer.uint32(10).string(message.clineVersion);
        }
        if (message.hookName !== "") {
            writer.uint32(18).string(message.hookName);
        }
        if (message.timestamp !== "") {
            writer.uint32(26).string(message.timestamp);
        }
        if (message.taskId !== "") {
            writer.uint32(34).string(message.taskId);
        }
        for (const v of message.workspaceRoots) {
            writer.uint32(42).string(v);
        }
        if (message.userId !== "") {
            writer.uint32(50).string(message.userId);
        }
        if (message.preToolUse !== undefined) {
            PreToolUseData.encode(message.preToolUse, writer.uint32(82).fork()).join();
        }
        if (message.postToolUse !== undefined) {
            PostToolUseData.encode(message.postToolUse, writer.uint32(90).fork()).join();
        }
        if (message.userPromptSubmit !== undefined) {
            UserPromptSubmitData.encode(message.userPromptSubmit, writer.uint32(98).fork()).join();
        }
        if (message.taskStart !== undefined) {
            TaskStartData.encode(message.taskStart, writer.uint32(106).fork()).join();
        }
        if (message.taskResume !== undefined) {
            TaskResumeData.encode(message.taskResume, writer.uint32(114).fork()).join();
        }
        if (message.taskCancel !== undefined) {
            TaskCancelData.encode(message.taskCancel, writer.uint32(122).fork()).join();
        }
        if (message.taskComplete !== undefined) {
            TaskCompleteData.encode(message.taskComplete, writer.uint32(130).fork()).join();
        }
        if (message.preCompact !== undefined) {
            PreCompactData.encode(message.preCompact, writer.uint32(138).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHookInput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.clineVersion = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.hookName = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.timestamp = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.taskId = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.workspaceRoots.push(reader.string());
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.userId = reader.string();
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.preToolUse = PreToolUseData.decode(reader, reader.uint32());
                    continue;
                }
                case 11: {
                    if (tag !== 90) {
                        break;
                    }
                    message.postToolUse = PostToolUseData.decode(reader, reader.uint32());
                    continue;
                }
                case 12: {
                    if (tag !== 98) {
                        break;
                    }
                    message.userPromptSubmit = UserPromptSubmitData.decode(reader, reader.uint32());
                    continue;
                }
                case 13: {
                    if (tag !== 106) {
                        break;
                    }
                    message.taskStart = TaskStartData.decode(reader, reader.uint32());
                    continue;
                }
                case 14: {
                    if (tag !== 114) {
                        break;
                    }
                    message.taskResume = TaskResumeData.decode(reader, reader.uint32());
                    continue;
                }
                case 15: {
                    if (tag !== 122) {
                        break;
                    }
                    message.taskCancel = TaskCancelData.decode(reader, reader.uint32());
                    continue;
                }
                case 16: {
                    if (tag !== 130) {
                        break;
                    }
                    message.taskComplete = TaskCompleteData.decode(reader, reader.uint32());
                    continue;
                }
                case 17: {
                    if (tag !== 138) {
                        break;
                    }
                    message.preCompact = PreCompactData.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            clineVersion: isSet(object.clineVersion) ? globalThis.String(object.clineVersion) : "",
            hookName: isSet(object.hookName) ? globalThis.String(object.hookName) : "",
            timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
            taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
            workspaceRoots: globalThis.Array.isArray(object?.workspaceRoots)
                ? object.workspaceRoots.map((e) => globalThis.String(e))
                : [],
            userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
            preToolUse: isSet(object.preToolUse) ? PreToolUseData.fromJSON(object.preToolUse) : undefined,
            postToolUse: isSet(object.postToolUse) ? PostToolUseData.fromJSON(object.postToolUse) : undefined,
            userPromptSubmit: isSet(object.userPromptSubmit)
                ? UserPromptSubmitData.fromJSON(object.userPromptSubmit)
                : undefined,
            taskStart: isSet(object.taskStart) ? TaskStartData.fromJSON(object.taskStart) : undefined,
            taskResume: isSet(object.taskResume) ? TaskResumeData.fromJSON(object.taskResume) : undefined,
            taskCancel: isSet(object.taskCancel) ? TaskCancelData.fromJSON(object.taskCancel) : undefined,
            taskComplete: isSet(object.taskComplete) ? TaskCompleteData.fromJSON(object.taskComplete) : undefined,
            preCompact: isSet(object.preCompact) ? PreCompactData.fromJSON(object.preCompact) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.clineVersion !== "") {
            obj.clineVersion = message.clineVersion;
        }
        if (message.hookName !== "") {
            obj.hookName = message.hookName;
        }
        if (message.timestamp !== "") {
            obj.timestamp = message.timestamp;
        }
        if (message.taskId !== "") {
            obj.taskId = message.taskId;
        }
        if (message.workspaceRoots?.length) {
            obj.workspaceRoots = message.workspaceRoots;
        }
        if (message.userId !== "") {
            obj.userId = message.userId;
        }
        if (message.preToolUse !== undefined) {
            obj.preToolUse = PreToolUseData.toJSON(message.preToolUse);
        }
        if (message.postToolUse !== undefined) {
            obj.postToolUse = PostToolUseData.toJSON(message.postToolUse);
        }
        if (message.userPromptSubmit !== undefined) {
            obj.userPromptSubmit = UserPromptSubmitData.toJSON(message.userPromptSubmit);
        }
        if (message.taskStart !== undefined) {
            obj.taskStart = TaskStartData.toJSON(message.taskStart);
        }
        if (message.taskResume !== undefined) {
            obj.taskResume = TaskResumeData.toJSON(message.taskResume);
        }
        if (message.taskCancel !== undefined) {
            obj.taskCancel = TaskCancelData.toJSON(message.taskCancel);
        }
        if (message.taskComplete !== undefined) {
            obj.taskComplete = TaskCompleteData.toJSON(message.taskComplete);
        }
        if (message.preCompact !== undefined) {
            obj.preCompact = PreCompactData.toJSON(message.preCompact);
        }
        return obj;
    },
    create(base) {
        return HookInput.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHookInput();
        message.clineVersion = object.clineVersion ?? "";
        message.hookName = object.hookName ?? "";
        message.timestamp = object.timestamp ?? "";
        message.taskId = object.taskId ?? "";
        message.workspaceRoots = object.workspaceRoots?.map((e) => e) || [];
        message.userId = object.userId ?? "";
        message.preToolUse = (object.preToolUse !== undefined && object.preToolUse !== null)
            ? PreToolUseData.fromPartial(object.preToolUse)
            : undefined;
        message.postToolUse = (object.postToolUse !== undefined && object.postToolUse !== null)
            ? PostToolUseData.fromPartial(object.postToolUse)
            : undefined;
        message.userPromptSubmit = (object.userPromptSubmit !== undefined && object.userPromptSubmit !== null)
            ? UserPromptSubmitData.fromPartial(object.userPromptSubmit)
            : undefined;
        message.taskStart = (object.taskStart !== undefined && object.taskStart !== null)
            ? TaskStartData.fromPartial(object.taskStart)
            : undefined;
        message.taskResume = (object.taskResume !== undefined && object.taskResume !== null)
            ? TaskResumeData.fromPartial(object.taskResume)
            : undefined;
        message.taskCancel = (object.taskCancel !== undefined && object.taskCancel !== null)
            ? TaskCancelData.fromPartial(object.taskCancel)
            : undefined;
        message.taskComplete = (object.taskComplete !== undefined && object.taskComplete !== null)
            ? TaskCompleteData.fromPartial(object.taskComplete)
            : undefined;
        message.preCompact = (object.preCompact !== undefined && object.preCompact !== null)
            ? PreCompactData.fromPartial(object.preCompact)
            : undefined;
        return message;
    },
};
function createBaseHookOutput() {
    return { contextModification: "", cancel: false, errorMessage: "" };
}
export const HookOutput = {
    encode(message, writer = new BinaryWriter()) {
        if (message.contextModification !== "") {
            writer.uint32(10).string(message.contextModification);
        }
        if (message.cancel !== false) {
            writer.uint32(16).bool(message.cancel);
        }
        if (message.errorMessage !== "") {
            writer.uint32(26).string(message.errorMessage);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHookOutput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.contextModification = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.cancel = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.errorMessage = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            contextModification: isSet(object.contextModification) ? globalThis.String(object.contextModification) : "",
            cancel: isSet(object.cancel) ? globalThis.Boolean(object.cancel) : false,
            errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.contextModification !== "") {
            obj.contextModification = message.contextModification;
        }
        if (message.cancel !== false) {
            obj.cancel = message.cancel;
        }
        if (message.errorMessage !== "") {
            obj.errorMessage = message.errorMessage;
        }
        return obj;
    },
    create(base) {
        return HookOutput.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHookOutput();
        message.contextModification = object.contextModification ?? "";
        message.cancel = object.cancel ?? false;
        message.errorMessage = object.errorMessage ?? "";
        return message;
    },
};
function createBasePreToolUseData() {
    return { toolName: "", parameters: {} };
}
export const PreToolUseData = {
    encode(message, writer = new BinaryWriter()) {
        if (message.toolName !== "") {
            writer.uint32(10).string(message.toolName);
        }
        Object.entries(message.parameters).forEach(([key, value]) => {
            PreToolUseData_ParametersEntry.encode({ key: key, value }, writer.uint32(18).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePreToolUseData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.toolName = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = PreToolUseData_ParametersEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.parameters[entry2.key] = entry2.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            toolName: isSet(object.toolName) ? globalThis.String(object.toolName) : "",
            parameters: isObject(object.parameters)
                ? Object.entries(object.parameters).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.toolName !== "") {
            obj.toolName = message.toolName;
        }
        if (message.parameters) {
            const entries = Object.entries(message.parameters);
            if (entries.length > 0) {
                obj.parameters = {};
                entries.forEach(([k, v]) => {
                    obj.parameters[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return PreToolUseData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePreToolUseData();
        message.toolName = object.toolName ?? "";
        message.parameters = Object.entries(object.parameters ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBasePreToolUseData_ParametersEntry() {
    return { key: "", value: "" };
}
export const PreToolUseData_ParametersEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePreToolUseData_ParametersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return PreToolUseData_ParametersEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePreToolUseData_ParametersEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBasePostToolUseData() {
    return { toolName: "", parameters: {}, result: "", success: false, executionTimeMs: 0 };
}
export const PostToolUseData = {
    encode(message, writer = new BinaryWriter()) {
        if (message.toolName !== "") {
            writer.uint32(10).string(message.toolName);
        }
        Object.entries(message.parameters).forEach(([key, value]) => {
            PostToolUseData_ParametersEntry.encode({ key: key, value }, writer.uint32(18).fork()).join();
        });
        if (message.result !== "") {
            writer.uint32(26).string(message.result);
        }
        if (message.success !== false) {
            writer.uint32(32).bool(message.success);
        }
        if (message.executionTimeMs !== 0) {
            writer.uint32(40).int64(message.executionTimeMs);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostToolUseData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.toolName = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = PostToolUseData_ParametersEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.parameters[entry2.key] = entry2.value;
                    }
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.result = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.success = reader.bool();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.executionTimeMs = longToNumber(reader.int64());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            toolName: isSet(object.toolName) ? globalThis.String(object.toolName) : "",
            parameters: isObject(object.parameters)
                ? Object.entries(object.parameters).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
            result: isSet(object.result) ? globalThis.String(object.result) : "",
            success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
            executionTimeMs: isSet(object.executionTimeMs) ? globalThis.Number(object.executionTimeMs) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.toolName !== "") {
            obj.toolName = message.toolName;
        }
        if (message.parameters) {
            const entries = Object.entries(message.parameters);
            if (entries.length > 0) {
                obj.parameters = {};
                entries.forEach(([k, v]) => {
                    obj.parameters[k] = v;
                });
            }
        }
        if (message.result !== "") {
            obj.result = message.result;
        }
        if (message.success !== false) {
            obj.success = message.success;
        }
        if (message.executionTimeMs !== 0) {
            obj.executionTimeMs = Math.round(message.executionTimeMs);
        }
        return obj;
    },
    create(base) {
        return PostToolUseData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePostToolUseData();
        message.toolName = object.toolName ?? "";
        message.parameters = Object.entries(object.parameters ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        message.result = object.result ?? "";
        message.success = object.success ?? false;
        message.executionTimeMs = object.executionTimeMs ?? 0;
        return message;
    },
};
function createBasePostToolUseData_ParametersEntry() {
    return { key: "", value: "" };
}
export const PostToolUseData_ParametersEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePostToolUseData_ParametersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return PostToolUseData_ParametersEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePostToolUseData_ParametersEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseUserPromptSubmitData() {
    return { prompt: "", attachments: [] };
}
export const UserPromptSubmitData = {
    encode(message, writer = new BinaryWriter()) {
        if (message.prompt !== "") {
            writer.uint32(10).string(message.prompt);
        }
        for (const v of message.attachments) {
            writer.uint32(18).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUserPromptSubmitData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.prompt = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.attachments.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            prompt: isSet(object.prompt) ? globalThis.String(object.prompt) : "",
            attachments: globalThis.Array.isArray(object?.attachments)
                ? object.attachments.map((e) => globalThis.String(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.prompt !== "") {
            obj.prompt = message.prompt;
        }
        if (message.attachments?.length) {
            obj.attachments = message.attachments;
        }
        return obj;
    },
    create(base) {
        return UserPromptSubmitData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUserPromptSubmitData();
        message.prompt = object.prompt ?? "";
        message.attachments = object.attachments?.map((e) => e) || [];
        return message;
    },
};
function createBaseTaskStartData() {
    return { taskMetadata: {} };
}
export const TaskStartData = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.taskMetadata).forEach(([key, value]) => {
            TaskStartData_TaskMetadataEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskStartData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = TaskStartData_TaskMetadataEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.taskMetadata[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            taskMetadata: isObject(object.taskMetadata)
                ? Object.entries(object.taskMetadata).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.taskMetadata) {
            const entries = Object.entries(message.taskMetadata);
            if (entries.length > 0) {
                obj.taskMetadata = {};
                entries.forEach(([k, v]) => {
                    obj.taskMetadata[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return TaskStartData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTaskStartData();
        message.taskMetadata = Object.entries(object.taskMetadata ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseTaskStartData_TaskMetadataEntry() {
    return { key: "", value: "" };
}
export const TaskStartData_TaskMetadataEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskStartData_TaskMetadataEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return TaskStartData_TaskMetadataEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTaskStartData_TaskMetadataEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseTaskResumeData() {
    return { taskMetadata: {}, previousState: {} };
}
export const TaskResumeData = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.taskMetadata).forEach(([key, value]) => {
            TaskResumeData_TaskMetadataEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        Object.entries(message.previousState).forEach(([key, value]) => {
            TaskResumeData_PreviousStateEntry.encode({ key: key, value }, writer.uint32(18).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskResumeData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = TaskResumeData_TaskMetadataEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.taskMetadata[entry1.key] = entry1.value;
                    }
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    const entry2 = TaskResumeData_PreviousStateEntry.decode(reader, reader.uint32());
                    if (entry2.value !== undefined) {
                        message.previousState[entry2.key] = entry2.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            taskMetadata: isObject(object.taskMetadata)
                ? Object.entries(object.taskMetadata).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
            previousState: isObject(object.previousState)
                ? Object.entries(object.previousState).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.taskMetadata) {
            const entries = Object.entries(message.taskMetadata);
            if (entries.length > 0) {
                obj.taskMetadata = {};
                entries.forEach(([k, v]) => {
                    obj.taskMetadata[k] = v;
                });
            }
        }
        if (message.previousState) {
            const entries = Object.entries(message.previousState);
            if (entries.length > 0) {
                obj.previousState = {};
                entries.forEach(([k, v]) => {
                    obj.previousState[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return TaskResumeData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTaskResumeData();
        message.taskMetadata = Object.entries(object.taskMetadata ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        message.previousState = Object.entries(object.previousState ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseTaskResumeData_TaskMetadataEntry() {
    return { key: "", value: "" };
}
export const TaskResumeData_TaskMetadataEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskResumeData_TaskMetadataEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return TaskResumeData_TaskMetadataEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTaskResumeData_TaskMetadataEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseTaskResumeData_PreviousStateEntry() {
    return { key: "", value: "" };
}
export const TaskResumeData_PreviousStateEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskResumeData_PreviousStateEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return TaskResumeData_PreviousStateEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTaskResumeData_PreviousStateEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseTaskCancelData() {
    return { taskMetadata: {} };
}
export const TaskCancelData = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.taskMetadata).forEach(([key, value]) => {
            TaskCancelData_TaskMetadataEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskCancelData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = TaskCancelData_TaskMetadataEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.taskMetadata[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            taskMetadata: isObject(object.taskMetadata)
                ? Object.entries(object.taskMetadata).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.taskMetadata) {
            const entries = Object.entries(message.taskMetadata);
            if (entries.length > 0) {
                obj.taskMetadata = {};
                entries.forEach(([k, v]) => {
                    obj.taskMetadata[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return TaskCancelData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTaskCancelData();
        message.taskMetadata = Object.entries(object.taskMetadata ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseTaskCancelData_TaskMetadataEntry() {
    return { key: "", value: "" };
}
export const TaskCancelData_TaskMetadataEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskCancelData_TaskMetadataEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return TaskCancelData_TaskMetadataEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTaskCancelData_TaskMetadataEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseTaskCompleteData() {
    return { taskMetadata: {} };
}
export const TaskCompleteData = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.taskMetadata).forEach(([key, value]) => {
            TaskCompleteData_TaskMetadataEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskCompleteData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = TaskCompleteData_TaskMetadataEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.taskMetadata[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            taskMetadata: isObject(object.taskMetadata)
                ? Object.entries(object.taskMetadata).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.taskMetadata) {
            const entries = Object.entries(message.taskMetadata);
            if (entries.length > 0) {
                obj.taskMetadata = {};
                entries.forEach(([k, v]) => {
                    obj.taskMetadata[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return TaskCompleteData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTaskCompleteData();
        message.taskMetadata = Object.entries(object.taskMetadata ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseTaskCompleteData_TaskMetadataEntry() {
    return { key: "", value: "" };
}
export const TaskCompleteData_TaskMetadataEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTaskCompleteData_TaskMetadataEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return TaskCompleteData_TaskMetadataEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTaskCompleteData_TaskMetadataEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBasePreCompactData() {
    return { contextSize: 0, messagesToCompact: 0, compactionStrategy: "" };
}
export const PreCompactData = {
    encode(message, writer = new BinaryWriter()) {
        if (message.contextSize !== 0) {
            writer.uint32(8).int64(message.contextSize);
        }
        if (message.messagesToCompact !== 0) {
            writer.uint32(16).int32(message.messagesToCompact);
        }
        if (message.compactionStrategy !== "") {
            writer.uint32(26).string(message.compactionStrategy);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePreCompactData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.contextSize = longToNumber(reader.int64());
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.messagesToCompact = reader.int32();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.compactionStrategy = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            contextSize: isSet(object.contextSize) ? globalThis.Number(object.contextSize) : 0,
            messagesToCompact: isSet(object.messagesToCompact) ? globalThis.Number(object.messagesToCompact) : 0,
            compactionStrategy: isSet(object.compactionStrategy) ? globalThis.String(object.compactionStrategy) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.contextSize !== 0) {
            obj.contextSize = Math.round(message.contextSize);
        }
        if (message.messagesToCompact !== 0) {
            obj.messagesToCompact = Math.round(message.messagesToCompact);
        }
        if (message.compactionStrategy !== "") {
            obj.compactionStrategy = message.compactionStrategy;
        }
        return obj;
    },
    create(base) {
        return PreCompactData.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePreCompactData();
        message.contextSize = object.contextSize ?? 0;
        message.messagesToCompact = object.messagesToCompact ?? 0;
        message.compactionStrategy = object.compactionStrategy ?? "";
        return message;
    },
};
function longToNumber(int64) {
    const num = globalThis.Number(int64.toString());
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return num;
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
