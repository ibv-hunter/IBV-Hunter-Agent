// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: cline/checkpoints.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { makeGenericClientConstructor, } from "@grpc/grpc-js";
import { Timestamp } from "../google/protobuf/timestamp.ts";
import { Empty, Int64Request, Metadata as Metadata1, StringArrayRequest } from "./common.ts";
export var CheckpointEvent_OperationType;
(function (CheckpointEvent_OperationType) {
    CheckpointEvent_OperationType[CheckpointEvent_OperationType["CHECKPOINT_INIT"] = 0] = "CHECKPOINT_INIT";
    CheckpointEvent_OperationType[CheckpointEvent_OperationType["CHECKPOINT_COMMIT"] = 1] = "CHECKPOINT_COMMIT";
    CheckpointEvent_OperationType[CheckpointEvent_OperationType["CHECKPOINT_RESTORE"] = 2] = "CHECKPOINT_RESTORE";
    CheckpointEvent_OperationType[CheckpointEvent_OperationType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CheckpointEvent_OperationType || (CheckpointEvent_OperationType = {}));
export function checkpointEvent_OperationTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "CHECKPOINT_INIT":
            return CheckpointEvent_OperationType.CHECKPOINT_INIT;
        case 1:
        case "CHECKPOINT_COMMIT":
            return CheckpointEvent_OperationType.CHECKPOINT_COMMIT;
        case 2:
        case "CHECKPOINT_RESTORE":
            return CheckpointEvent_OperationType.CHECKPOINT_RESTORE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return CheckpointEvent_OperationType.UNRECOGNIZED;
    }
}
export function checkpointEvent_OperationTypeToJSON(object) {
    switch (object) {
        case CheckpointEvent_OperationType.CHECKPOINT_INIT:
            return "CHECKPOINT_INIT";
        case CheckpointEvent_OperationType.CHECKPOINT_COMMIT:
            return "CHECKPOINT_COMMIT";
        case CheckpointEvent_OperationType.CHECKPOINT_RESTORE:
            return "CHECKPOINT_RESTORE";
        case CheckpointEvent_OperationType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseCheckpointRestoreRequest() {
    return { metadata: undefined, number: 0, restoreType: "", offset: undefined };
}
export const CheckpointRestoreRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.metadata !== undefined) {
            Metadata1.encode(message.metadata, writer.uint32(10).fork()).join();
        }
        if (message.number !== 0) {
            writer.uint32(16).int64(message.number);
        }
        if (message.restoreType !== "") {
            writer.uint32(26).string(message.restoreType);
        }
        if (message.offset !== undefined) {
            writer.uint32(32).int64(message.offset);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckpointRestoreRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata1.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.number = longToNumber(reader.int64());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.restoreType = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.offset = longToNumber(reader.int64());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadata: isSet(object.metadata) ? Metadata1.fromJSON(object.metadata) : undefined,
            number: isSet(object.number) ? globalThis.Number(object.number) : 0,
            restoreType: isSet(object.restoreType) ? globalThis.String(object.restoreType) : "",
            offset: isSet(object.offset) ? globalThis.Number(object.offset) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata1.toJSON(message.metadata);
        }
        if (message.number !== 0) {
            obj.number = Math.round(message.number);
        }
        if (message.restoreType !== "") {
            obj.restoreType = message.restoreType;
        }
        if (message.offset !== undefined) {
            obj.offset = Math.round(message.offset);
        }
        return obj;
    },
    create(base) {
        return CheckpointRestoreRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCheckpointRestoreRequest();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata1.fromPartial(object.metadata)
            : undefined;
        message.number = object.number ?? 0;
        message.restoreType = object.restoreType ?? "";
        message.offset = object.offset ?? undefined;
        return message;
    },
};
function createBaseCheckpointSubscriptionRequest() {
    return { cwdHash: "" };
}
export const CheckpointSubscriptionRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.cwdHash !== "") {
            writer.uint32(10).string(message.cwdHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckpointSubscriptionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.cwdHash = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { cwdHash: isSet(object.cwdHash) ? globalThis.String(object.cwdHash) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.cwdHash !== "") {
            obj.cwdHash = message.cwdHash;
        }
        return obj;
    },
    create(base) {
        return CheckpointSubscriptionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCheckpointSubscriptionRequest();
        message.cwdHash = object.cwdHash ?? "";
        return message;
    },
};
function createBaseCheckpointEvent() {
    return { operation: 0, cwdHash: "", isActive: false, timestamp: undefined, taskId: undefined, commitHash: undefined };
}
export const CheckpointEvent = {
    encode(message, writer = new BinaryWriter()) {
        if (message.operation !== 0) {
            writer.uint32(8).int32(message.operation);
        }
        if (message.cwdHash !== "") {
            writer.uint32(18).string(message.cwdHash);
        }
        if (message.isActive !== false) {
            writer.uint32(24).bool(message.isActive);
        }
        if (message.timestamp !== undefined) {
            Timestamp.encode(message.timestamp, writer.uint32(34).fork()).join();
        }
        if (message.taskId !== undefined) {
            writer.uint32(42).string(message.taskId);
        }
        if (message.commitHash !== undefined) {
            writer.uint32(50).string(message.commitHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCheckpointEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.operation = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.cwdHash = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.isActive = reader.bool();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.timestamp = Timestamp.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.taskId = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.commitHash = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            operation: isSet(object.operation) ? checkpointEvent_OperationTypeFromJSON(object.operation) : 0,
            cwdHash: isSet(object.cwdHash) ? globalThis.String(object.cwdHash) : "",
            isActive: isSet(object.isActive) ? globalThis.Boolean(object.isActive) : false,
            timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
            taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : undefined,
            commitHash: isSet(object.commitHash) ? globalThis.String(object.commitHash) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.operation !== 0) {
            obj.operation = checkpointEvent_OperationTypeToJSON(message.operation);
        }
        if (message.cwdHash !== "") {
            obj.cwdHash = message.cwdHash;
        }
        if (message.isActive !== false) {
            obj.isActive = message.isActive;
        }
        if (message.timestamp !== undefined) {
            obj.timestamp = fromTimestamp(message.timestamp).toISOString();
        }
        if (message.taskId !== undefined) {
            obj.taskId = message.taskId;
        }
        if (message.commitHash !== undefined) {
            obj.commitHash = message.commitHash;
        }
        return obj;
    },
    create(base) {
        return CheckpointEvent.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCheckpointEvent();
        message.operation = object.operation ?? 0;
        message.cwdHash = object.cwdHash ?? "";
        message.isActive = object.isActive ?? false;
        message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
            ? Timestamp.fromPartial(object.timestamp)
            : undefined;
        message.taskId = object.taskId ?? undefined;
        message.commitHash = object.commitHash ?? undefined;
        return message;
    },
};
function createBasePathHashMap() {
    return { pathHash: {} };
}
export const PathHashMap = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.pathHash).forEach(([key, value]) => {
            PathHashMap_PathHashEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePathHashMap();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = PathHashMap_PathHashEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.pathHash[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            pathHash: isObject(object.pathHash)
                ? Object.entries(object.pathHash).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.pathHash) {
            const entries = Object.entries(message.pathHash);
            if (entries.length > 0) {
                obj.pathHash = {};
                entries.forEach(([k, v]) => {
                    obj.pathHash[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return PathHashMap.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePathHashMap();
        message.pathHash = Object.entries(object.pathHash ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBasePathHashMap_PathHashEntry() {
    return { key: "", value: "" };
}
export const PathHashMap_PathHashEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePathHashMap_PathHashEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return PathHashMap_PathHashEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePathHashMap_PathHashEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
export const CheckpointsServiceDefinition = {
    name: "CheckpointsService",
    fullName: "cline.CheckpointsService",
    methods: {
        checkpointDiff: {
            name: "checkpointDiff",
            requestType: Int64Request,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        checkpointRestore: {
            name: "checkpointRestore",
            requestType: CheckpointRestoreRequest,
            requestStream: false,
            responseType: Empty,
            responseStream: false,
            options: {},
        },
        subscribeToCheckpoints: {
            name: "subscribeToCheckpoints",
            requestType: CheckpointSubscriptionRequest,
            requestStream: false,
            responseType: CheckpointEvent,
            responseStream: true,
            options: {},
        },
        getCwdHash: {
            name: "getCwdHash",
            requestType: StringArrayRequest,
            requestStream: false,
            responseType: PathHashMap,
            responseStream: false,
            options: {},
        },
    },
};
export const CheckpointsServiceService = {
    checkpointDiff: {
        path: "/cline.CheckpointsService/checkpointDiff",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(Int64Request.encode(value).finish()),
        requestDeserialize: (value) => Int64Request.decode(value),
        responseSerialize: (value) => Buffer.from(Empty.encode(value).finish()),
        responseDeserialize: (value) => Empty.decode(value),
    },
    checkpointRestore: {
        path: "/cline.CheckpointsService/checkpointRestore",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(CheckpointRestoreRequest.encode(value).finish()),
        requestDeserialize: (value) => CheckpointRestoreRequest.decode(value),
        responseSerialize: (value) => Buffer.from(Empty.encode(value).finish()),
        responseDeserialize: (value) => Empty.decode(value),
    },
    subscribeToCheckpoints: {
        path: "/cline.CheckpointsService/subscribeToCheckpoints",
        requestStream: false,
        responseStream: true,
        requestSerialize: (value) => Buffer.from(CheckpointSubscriptionRequest.encode(value).finish()),
        requestDeserialize: (value) => CheckpointSubscriptionRequest.decode(value),
        responseSerialize: (value) => Buffer.from(CheckpointEvent.encode(value).finish()),
        responseDeserialize: (value) => CheckpointEvent.decode(value),
    },
    getCwdHash: {
        path: "/cline.CheckpointsService/getCwdHash",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(StringArrayRequest.encode(value).finish()),
        requestDeserialize: (value) => StringArrayRequest.decode(value),
        responseSerialize: (value) => Buffer.from(PathHashMap.encode(value).finish()),
        responseDeserialize: (value) => PathHashMap.decode(value),
    },
};
export const CheckpointsServiceClient = makeGenericClientConstructor(CheckpointsServiceService, "cline.CheckpointsService");
function toTimestamp(date) {
    const seconds = Math.trunc(date.getTime() / 1000);
    const nanos = (date.getTime() % 1000) * 1000000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1000;
    millis += (t.nanos || 0) / 1000000;
    return new globalThis.Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof globalThis.Date) {
        return toTimestamp(o);
    }
    else if (typeof o === "string") {
        return toTimestamp(new globalThis.Date(o));
    }
    else {
        return Timestamp.fromJSON(o);
    }
}
function longToNumber(int64) {
    const num = globalThis.Number(int64.toString());
    if (num > globalThis.Number.MAX_SAFE_INTEGER) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (num < globalThis.Number.MIN_SAFE_INTEGER) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return num;
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
