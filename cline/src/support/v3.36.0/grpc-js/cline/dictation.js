// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v3.19.1
// source: cline/dictation.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { makeGenericClientConstructor, } from "@grpc/grpc-js";
import { EmptyRequest } from "./common.ts";
function createBaseTranscribeAudioRequest() {
    return { audioBase64: "", language: "" };
}
export const TranscribeAudioRequest = {
    encode(message, writer = new BinaryWriter()) {
        if (message.audioBase64 !== "") {
            writer.uint32(18).string(message.audioBase64);
        }
        if (message.language !== "") {
            writer.uint32(26).string(message.language);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTranscribeAudioRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.audioBase64 = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.language = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            audioBase64: isSet(object.audioBase64) ? globalThis.String(object.audioBase64) : "",
            language: isSet(object.language) ? globalThis.String(object.language) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.audioBase64 !== "") {
            obj.audioBase64 = message.audioBase64;
        }
        if (message.language !== "") {
            obj.language = message.language;
        }
        return obj;
    },
    create(base) {
        return TranscribeAudioRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTranscribeAudioRequest();
        message.audioBase64 = object.audioBase64 ?? "";
        message.language = object.language ?? "";
        return message;
    },
};
function createBaseRecordingResult() {
    return { success: false, error: "" };
}
export const RecordingResult = {
    encode(message, writer = new BinaryWriter()) {
        if (message.success !== false) {
            writer.uint32(8).bool(message.success);
        }
        if (message.error !== "") {
            writer.uint32(18).string(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecordingResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.success = reader.bool();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
            error: isSet(object.error) ? globalThis.String(object.error) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.success !== false) {
            obj.success = message.success;
        }
        if (message.error !== "") {
            obj.error = message.error;
        }
        return obj;
    },
    create(base) {
        return RecordingResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRecordingResult();
        message.success = object.success ?? false;
        message.error = object.error ?? "";
        return message;
    },
};
function createBaseRecordedAudio() {
    return { success: false, audioBase64: "", error: "" };
}
export const RecordedAudio = {
    encode(message, writer = new BinaryWriter()) {
        if (message.success !== false) {
            writer.uint32(8).bool(message.success);
        }
        if (message.audioBase64 !== "") {
            writer.uint32(18).string(message.audioBase64);
        }
        if (message.error !== "") {
            writer.uint32(26).string(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecordedAudio();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.success = reader.bool();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.audioBase64 = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
            audioBase64: isSet(object.audioBase64) ? globalThis.String(object.audioBase64) : "",
            error: isSet(object.error) ? globalThis.String(object.error) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.success !== false) {
            obj.success = message.success;
        }
        if (message.audioBase64 !== "") {
            obj.audioBase64 = message.audioBase64;
        }
        if (message.error !== "") {
            obj.error = message.error;
        }
        return obj;
    },
    create(base) {
        return RecordedAudio.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRecordedAudio();
        message.success = object.success ?? false;
        message.audioBase64 = object.audioBase64 ?? "";
        message.error = object.error ?? "";
        return message;
    },
};
function createBaseRecordingStatus() {
    return { isRecording: false, durationSeconds: 0, error: "" };
}
export const RecordingStatus = {
    encode(message, writer = new BinaryWriter()) {
        if (message.isRecording !== false) {
            writer.uint32(8).bool(message.isRecording);
        }
        if (message.durationSeconds !== 0) {
            writer.uint32(17).double(message.durationSeconds);
        }
        if (message.error !== "") {
            writer.uint32(26).string(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRecordingStatus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.isRecording = reader.bool();
                    continue;
                }
                case 2: {
                    if (tag !== 17) {
                        break;
                    }
                    message.durationSeconds = reader.double();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            isRecording: isSet(object.isRecording) ? globalThis.Boolean(object.isRecording) : false,
            durationSeconds: isSet(object.durationSeconds) ? globalThis.Number(object.durationSeconds) : 0,
            error: isSet(object.error) ? globalThis.String(object.error) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.isRecording !== false) {
            obj.isRecording = message.isRecording;
        }
        if (message.durationSeconds !== 0) {
            obj.durationSeconds = message.durationSeconds;
        }
        if (message.error !== "") {
            obj.error = message.error;
        }
        return obj;
    },
    create(base) {
        return RecordingStatus.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRecordingStatus();
        message.isRecording = object.isRecording ?? false;
        message.durationSeconds = object.durationSeconds ?? 0;
        message.error = object.error ?? "";
        return message;
    },
};
function createBaseTranscription() {
    return { text: "", error: "" };
}
export const Transcription = {
    encode(message, writer = new BinaryWriter()) {
        if (message.text !== "") {
            writer.uint32(10).string(message.text);
        }
        if (message.error !== "") {
            writer.uint32(18).string(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTranscription();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.text = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            text: isSet(object.text) ? globalThis.String(object.text) : "",
            error: isSet(object.error) ? globalThis.String(object.error) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.text !== "") {
            obj.text = message.text;
        }
        if (message.error !== "") {
            obj.error = message.error;
        }
        return obj;
    },
    create(base) {
        return Transcription.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTranscription();
        message.text = object.text ?? "";
        message.error = object.error ?? "";
        return message;
    },
};
export const DictationServiceDefinition = {
    name: "DictationService",
    fullName: "cline.DictationService",
    methods: {
        startRecording: {
            name: "startRecording",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: RecordingResult,
            responseStream: false,
            options: {},
        },
        stopRecording: {
            name: "stopRecording",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: RecordedAudio,
            responseStream: false,
            options: {},
        },
        cancelRecording: {
            name: "cancelRecording",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: RecordingResult,
            responseStream: false,
            options: {},
        },
        getRecordingStatus: {
            name: "getRecordingStatus",
            requestType: EmptyRequest,
            requestStream: false,
            responseType: RecordingStatus,
            responseStream: false,
            options: {},
        },
        transcribeAudio: {
            name: "transcribeAudio",
            requestType: TranscribeAudioRequest,
            requestStream: false,
            responseType: Transcription,
            responseStream: false,
            options: {},
        },
    },
};
export const DictationServiceService = {
    startRecording: {
        path: "/cline.DictationService/startRecording",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(EmptyRequest.encode(value).finish()),
        requestDeserialize: (value) => EmptyRequest.decode(value),
        responseSerialize: (value) => Buffer.from(RecordingResult.encode(value).finish()),
        responseDeserialize: (value) => RecordingResult.decode(value),
    },
    stopRecording: {
        path: "/cline.DictationService/stopRecording",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(EmptyRequest.encode(value).finish()),
        requestDeserialize: (value) => EmptyRequest.decode(value),
        responseSerialize: (value) => Buffer.from(RecordedAudio.encode(value).finish()),
        responseDeserialize: (value) => RecordedAudio.decode(value),
    },
    cancelRecording: {
        path: "/cline.DictationService/cancelRecording",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(EmptyRequest.encode(value).finish()),
        requestDeserialize: (value) => EmptyRequest.decode(value),
        responseSerialize: (value) => Buffer.from(RecordingResult.encode(value).finish()),
        responseDeserialize: (value) => RecordingResult.decode(value),
    },
    getRecordingStatus: {
        path: "/cline.DictationService/getRecordingStatus",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(EmptyRequest.encode(value).finish()),
        requestDeserialize: (value) => EmptyRequest.decode(value),
        responseSerialize: (value) => Buffer.from(RecordingStatus.encode(value).finish()),
        responseDeserialize: (value) => RecordingStatus.decode(value),
    },
    transcribeAudio: {
        path: "/cline.DictationService/transcribeAudio",
        requestStream: false,
        responseStream: false,
        requestSerialize: (value) => Buffer.from(TranscribeAudioRequest.encode(value).finish()),
        requestDeserialize: (value) => TranscribeAudioRequest.decode(value),
        responseSerialize: (value) => Buffer.from(Transcription.encode(value).finish()),
        responseDeserialize: (value) => Transcription.decode(value),
    },
};
export const DictationServiceClient = makeGenericClientConstructor(DictationServiceService, "cline.DictationService");
function isSet(value) {
    return value !== null && value !== undefined;
}
