# Android AI Vulnerability Discovery Tool (Next Version)

## Special Note
Because the cline standalone mode requires communication using gRPC and cline core, the gRPC interface definitions may change between different cline versions. Therefore, please strictly use the specified version of cline for deployment. I will periodically update and adapt to the latest cline versions, generally upgrading when the second digit of the version number changes.

## Deployment Method
### 1. Configure Node.js 22 and Java 21
First, download and configure **Node.js 22** from the [official website](https://nodejs.org/en/download). Note that if you use brew to install node@22 on macOS, you need to manually configure the environment variables:
```bash
echo 'export PATH="/opt/homebrew/opt/node@22/bin:$PATH"' >> ~/.zshrc
```
Install npm:
```sh
# MacOS
brew install npm
# Linux/WSL
apt-get install npm
```
Install JDK 21:
```bash
# MacOS
brew install openjdk@21
## or
brew install --cask microsoft-openjdk@21

# Linux/WSL
apt-get install openjdk-21-jdk-headless
```

### 2. Install cline standalone
**Note: The currently supported cline version is: v3.36.0 ([link](https://github.com/cline/cline/releases/tag/v3.36.0))**
```sh
git clone https://github.com/cline/cline
cd cline
git checkout v3.36.0

npm run install:all
npm run compile-standalone
```
After compilation, a `standalone.zip` file will be generated in `dist-standalone`. If you already have a pre-compiled `standalone.zip` binary version, you can skip the compilation process. Whether compiled or obtained directly, the files must ultimately be copied to `~/.cline/core/dev-instance/`:
```bash
# Delete the old version
rm -rf ~/.cline/core/dev-instance/

mkdir -p ~/.cline/core/dev-instance/
cp standalone.zip ~/.cline/core/dev-instance/
cd ~/.cline/core/dev-instance/
unzip standalone.zip > /dev/null
rm standalone.zip
```

### 3. Configure Model Parameters and MCP (Skip if migrating from an older version)
Model information configuration is located in `cline/src/model-config/config.ts`.  Do not modify this unless necessary. If you need to temporarily test a new model, you can modify it locally but do not commit the changes to git:
```ts
// See ApiProvider enumeration in src/grpc-js/cline/models.ts
export const API_PROVIDER = "GEMINI"
export const API_MODEL_ID = "Gemini-2.5-flash"
```
The API Key configuration has now been changed to environment variables:
```ts
export const GEMINI_API_KEY = process.env.GEMINI_API_KEY || ""
```
You can configure them via environment variables:
```bash
export GEMINI_API_KEY="Your GEMINI_API_KEY"
```
Other parameters are all default. If needed, you can modify them in `updateApiConfigurationProto` in `cline/src/cline-api.ts`. Note: In cline standalone mode, any modification of model parameters must be done through the `UpdateApiConfigurationRequest` gRPC request, not by modifying a configuration file.  See `cline/cline-support/{version}/grpc-js/cline/models.ts` for the definition of specific configuration items in `ModelsApiConfiguration`.

The MCP configuration file is located at `~/.cline/data/settings/cline_mcp_settings.json`. It is recommended to reuse the configuration from the plugin version of cline; this way, you only need to fill in the MCP server in the plugin's graphical interface. For macOS, you can create a symbolic link as follows:
```sh
mkdir -p ~/.cline/data/settings/
ln -s ~/Library/Application\ Support/Code/User/globalStorage/saoudrizwan.claude-dev/settings/cline_mcp_settings.json ~/.cline/data/settings/cline_mcp_settings.json
```

### 4. Configuring this project
First, build the cline-exec written in TypeScript:
```sh
cd cline
npm install
npm run build
```
The compiled `cline/dist/cline-exec.js` is a single JS file generated by esbuild, but it still requires `cline/node_modules` to run. `node_modules` must be in the same directory as `cline-exec.js` or in its parent directory. It automatically manages Cline core and Cline hostbridge, requiring no manual management:
```bash
node cline-exec.js <prompt>
```
Then build AppScan.jar and FrameworkScan.jar; the output will be located in `build/libs/`.  You can also build them using IntelliJ IDEA:
```bash
./gradlew buildScanners
```
AppScan.jar, FrameworkScan.jar, and cline-exec.js need to be in the same directory, so the final directory structure should look like this:
```bash
% ls -l
total 47424
-rw-r--r--@  1 user  staff  11561980 12 17 11:33 AppScan.jar
-rwxr-xr-x@  1 user  staff   1152450 12 16 19:37 cline-exec.js
-rw-r--r--@  1 user  staff  11561839 12 17 11:37 FrameworkScan.jar
drwxr-xr-x@ 35 user  staff      1120 12 16 15:16 node_modules
```

## AppScan Usage
Use AppScan.jar directly for scanning, in conjunction with jebmcp. The parameters are as follows:
```
-i, --input INPUT     File path, can be an apk file or a folder containing several apks.
-o, --output OUTPUT   Specifies the output result file directory. The file name will be constructed based on the apk file name and scanning workflow information.
-m, --manifest MANIFEST
Specifies the path to the workflow manifest configuration file.
-w, --workflow WORKFLOW
Specifies the vulnerability workflow items to run, in the format: <type>.<name>. Using <type>.* will execute all workflows under a specific vulnerability type, and using all will execute all workflows.
--thread THREAD       Enables multi-threading for this scan, specifying the number of threads. Default value: 1.
--no-resume           Disables the resume function for this scan; it will not read saved state files and completed records, etc. Default value: False.
--retry-failed        This scan will only retry the failed items from the previous scan.
``` This parameter is invalid when --no-resume is specified, default value: False.
--remote              Use the remote jebmcp service for this scan, default value: False.
```
Usage examples:
```bash
# Single apk
java -jar AppScan.jar -i /Users/me/Reverse/Benchmark/1.apk -o /Users/me/Reverse/Benchmark/Results -m ./IBV-Hunter-Prompt/appscan-manifest.json -w all
# Multiple apks
java -jar AppScan.jar -i /Users/me/Reverse/Benchmark -o /Users/me/Reverse/Benchmark/Results -m ./IBV-Hunter-Prompt/appscan-manifest.json -w all
```

## FrameworkScan Usage
Use FrameworkScan.jar directly for scanning, in conjunction with jadx-daemon-mcp. The parameters are as follows:
```
-i, --input INPUT     File path, can be an apk file or a folder containing several apks.
-o, --output OUTPUT   Specify the output results file directory. The file name will be constructed based on the apk file name and scan workflow information.
-m, --manifest MANIFEST
Specify the path to the workflow manifest configuration file.
-w, --workflow WORKFLOW
Specify the vulnerability workflow items to run, format: <type>.<name>. Use <type>.* to execute all workflows under a specific vulnerability type, use all to execute all workflows.
-s, --service-scope SERVICE_SCOPE
Specify the range of system services to scan, generally a file containing a list of accessible system services, default value: empty, i.e., no service filtering.
--thread THREAD       Enable multi-threading for this scan, specify the number of threads, default value: 1.
--no-resume           Disable the resume function for this scan; it will not read saved state files and completed records, default value: False.
--retry-failed        This scan will only retry the failed items from the previous scan.
```
This parameter is invalid when --no-resume is specified. Default value: False.
```
Example usage:
```bash
java -jar AppScan.jar -i /Users/me/Firmware/ROM1/packages/android -o /Users/me/Firmware/ROM1/Results -m ./IBV-Hunter-Prompt/aospscan-manifest.json -w all
```